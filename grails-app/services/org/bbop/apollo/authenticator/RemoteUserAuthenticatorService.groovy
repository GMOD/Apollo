package org.bbop.apollo.authenticator

import grails.transaction.Transactional
import org.apache.shiro.SecurityUtils
import org.apache.shiro.authc.UsernamePasswordToken
import org.apache.shiro.crypto.hash.Sha256Hash
import org.apache.shiro.subject.Subject
import org.bbop.apollo.User
import org.bbop.apollo.gwt.shared.ClientTokenGenerator
import org.bbop.apollo.gwt.shared.FeatureStringEnum

import javax.servlet.http.HttpServletRequest

@Transactional
class RemoteUserAuthenticatorService implements AuthenticatorService {

    def authenticate(HttpServletRequest request) {
        try {

            // TODO: remove .. . . testing only
            String remoteUser
            if (!request.getHeader(FeatureStringEnum.REMOTE_USER.value)) {
                remoteUser = "abcd@123.com"
            } else {
                remoteUser = request.getHeader(FeatureStringEnum.REMOTE_USER.value)
            }
            if (!remoteUser) {
                log.warn("No remote user passed in header!")
                return false
            }
//            }
            UsernamePasswordToken authToken = new UsernamePasswordToken()
            authToken.username = remoteUser
            User user = User.findByUsername(authToken.username)
            if (!user) {

                String randomPassword = ClientTokenGenerator.generateRandomString()
                String passwordHash = new Sha256Hash(randomPassword).toHex()

                // TODO: created a reversible autogenerated database
//                String mungedString = randomPassword.reverse()

                user = new User(
                        username: remoteUser,
                        passwordHash: passwordHash,
                        firstName: "REMOTE_USER",
                        lastName: "${remoteUser}",
                        metadata: randomPassword// reversible autogenerated password
                ).save(insert: true, flush: true)
            }

            // retrieve reversed string
//            String generatedPassword = user.metadata

//            authToken.password = new Sha256Hash(user.metadata)
            authToken.password = user.metadata

            Subject subject = SecurityUtils.getSubject();
//            Session session = request.getSession(true)
//            Session session = subject.getSession(true);
            subject.login(authToken)
            if (!subject.authenticated) {
                log.error "Failed to authenticate user ${authToken.username}"
                return false
            }
        } catch (Exception ae) {
            log.error("Problem authenticating: " + ae.fillInStackTrace())
            return false
        }

    }

    //    @Override
    def authenticate(UsernamePasswordToken authToken, HttpServletRequest request) {
        // token is ignored
        return authToken(request)
    }
}
